

<!DOCTYPE html>
<html class="writer-html5" lang="fr" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>src.clusterizer.clusterizer &mdash; Documentation Ecosystème logistique </title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/my_theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Recherche" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Ecosystème logistique
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Rechercher docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/src.clusterizer.clusterizer.html">src.clusterizer.clusterizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/src.clusterizer.utils.clusterizer_utils.html">src.clusterizer.utils.clusterizer_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/src.clusterizer.utils.NAF_utils.html">src.clusterizer.utils.NAF_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/src.clusterizer.utils.seine_data_utils.html">src.clusterizer.utils.seine_data_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/tests.tests_src.test.html">tests.tests_src.test</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Ecosystème logistique</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Code du module</a> &raquo;</li>
        
      <li>src.clusterizer.clusterizer</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Code source de src.clusterizer.clusterizer</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Fichier principal s&#39;occupant de la clusterisation</span>
<span class="sd">à partir de la base de données et des paramètres choisis par l&#39;utilisateur.</span>

<span class="sd">Le module : </span>
<span class="sd">    - ouvre le fichier :code:`json` contenant la base SIRENE réduite aux données utiles</span>
<span class="sd">    - sélectionne les établissements correspondants aux codes NAF rentrés par l&#39;utilisateur</span>
<span class="sd">    - garde tous les établissements dans une certain rayon autour du centre de Paris (rayon choisi par l&#39;utilisateur)</span>
<span class="sd">    - si demandé, sépare les ponits en zones en fonction des cours d&#39;eau d&#39;Île-de-France avec le module :code:`utils/seine_data_utils`</span>
<span class="sd">    - regroupe les points en clusters avec l&#39;algorithme :code:`MiniBatchKMeans` de :code:`scikit-learn`</span>
<span class="sd">    - exporte le résultat sous forme de carte (dans un fichier `HTML`) à l&#39;aide du module :code:`folium` </span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pformat</span><span class="p">,</span> <span class="n">pprint</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">folium</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Array</span><span class="p">,</span> <span class="n">RawArray</span>

<span class="kn">import</span> <span class="nn">cProfile</span>

<span class="kn">from</span> <span class="nn">pycallgraph</span> <span class="kn">import</span> <span class="n">PyCallGraph</span>
<span class="kn">from</span> <span class="nn">pycallgraph.output</span> <span class="kn">import</span> <span class="n">GraphvizOutput</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">shapely.geometry.multipolygon</span> <span class="kn">import</span> <span class="n">MultiPolygon</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;../../&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span><span class="p">,</span> <span class="n">MiniBatchKMeans</span>

<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">Point</span>

<span class="kn">from</span> <span class="nn">src.clusterizer.utils</span> <span class="kn">import</span> <span class="n">NAF_utils</span>
<span class="kn">from</span> <span class="nn">src.clusterizer.utils</span> <span class="kn">import</span> <span class="n">clusterizer_utils</span>
<span class="kn">from</span> <span class="nn">src.clusterizer.utils.clusterizer_utils</span> <span class="kn">import</span> <span class="n">COLUMN_HULLS_NAME</span><span class="p">,</span> \
                                                    <span class="n">COLUMN_CLUSTER_INDEX_NAME</span><span class="p">,</span> \
                                                    <span class="n">COLUMN_CLUSTER_SIZE_NAME</span><span class="p">,</span> \
                                                    <span class="n">COLUMN_CENTROIDS_NAME</span><span class="p">,</span> \
                                                    <span class="n">COLUMN_DEFAULT_GEOMETRY_NAME</span><span class="p">,</span> \
                                                    <span class="n">COLUMN_CLUSTER_MASS_NAME</span>
<span class="kn">from</span> <span class="nn">src.clusterizer.utils.seine_data_utils</span> <span class="kn">import</span> <span class="n">DICT_GDF_ZONES</span><span class="p">,</span> <span class="n">NB_ZONES</span><span class="p">,</span> <span class="n">rapport_a_la_seine_multiprocessing</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Clusterise en utilisant l&#39;algorithme des k-moyennes.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">DEBUG_PLOT</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># pour afficher les points et frontières (debugging)</span>


<div class="viewcode-block" id="nettoyer"><a class="viewcode-back" href="../../../generated/src.clusterizer.clusterizer.nettoyer.html#src.clusterizer.clusterizer.nettoyer">[docs]</a><span class="k">def</span> <span class="nf">nettoyer</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">reduce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">column_geometry</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">COLUMN_DEFAULT_GEOMETRY_NAME</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Nettoie la DataFrame. Enlève les na.</span>
<span class="sd">    Si spécifié, ne retient que les premières données de la DataFrame.</span>

<span class="sd">    :param df: La DataFrame.</span>
<span class="sd">    :param reduce: Si True, ne prend que les premières données.</span>
<span class="sd">    :param threshold: Dans le cas où reduce=True, nombre de données à sélectionner.</span>
<span class="sd">    :param column_geometry: A spécifier si la colonne contenant les points n&#39;est pas la colonne par défaut (&quot;geometry&quot;)</span>
<span class="sd">    :return: Une DataFrame nettoyée.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">reduce</span> <span class="ow">and</span> <span class="n">df</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[:</span><span class="n">threshold</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column_geometry</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="clusterize"><a class="viewcode-back" href="../../../generated/src.clusterizer.clusterizer.clusterize.html#src.clusterizer.clusterizer.clusterize">[docs]</a><span class="k">def</span> <span class="nf">clusterize</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">column_geometry</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">COLUMN_DEFAULT_GEOMETRY_NAME</span><span class="p">,</span> <span class="n">is_dict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">weight</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clusterise à l&#39;aide de l&#39;algorithme des k-moyennes. Attention, fait du en-place.</span>

<span class="sd">    :param df: La (Geo)DataFrame contenant les points à clusteriser.</span>
<span class="sd">    :param k: Le nombre de clusters à calculer.</span>
<span class="sd">    :param column_geometry: A spécifier si la colonne contenant les points n&#39;est pas la colonne par défaut (&quot;geometry&quot;)</span>
<span class="sd">    :param is_dict: Indiquer True si jamais la colonne contenant les points ne contient pas d&#39;objets</span>
<span class="sd">     shapely.geometry.Points, mais un dictionnaire (en général, lorsque le fichier provient d&#39;un GeoJSON)</span>
<span class="sd">    :return: Deux GeoDataFrame.</span>
<span class="sd">     Une première GeoDataFrame entrée contenant une colonne en plus (&quot;cluster&quot;) : celle-ci permet de savoir pour chaque</span>
<span class="sd">     point le numéro du cluster qui lui a été affecté.</span>
<span class="sd">     Une deuxième GeoDataFrame contenant les informations détaillées de chaque cluster : centre de masse (&quot;centroids&quot;),</span>
<span class="sd">     enveloppe convexe (&quot;hulls&quot;) et nombre d&#39;établissements dans le cluster (&quot;taille&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ===========================================================</span>
    <span class="c1"># Commençons par faire le clustering et récupérer les centres</span>
    <span class="c1"># ==========================================================</span>


    <span class="n">mbk</span> <span class="o">=</span> <span class="n">MiniBatchKMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">2048</span><span class="p">)</span>  <span class="c1"># ça va plus vite</span>

    <span class="c1"># Ceci contient des coordonnées (x, y) des points</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">clusterizer_utils</span><span class="o">.</span><span class="n">get_coords_from_object</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">column_geometry</span><span class="p">,</span> <span class="n">is_dict</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Table vide&quot;</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">clusterizer_utils</span><span class="o">.</span><span class="n">vectorized_calculer_poids_code_NAF</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;apet700&quot;</span><span class="p">])</span> <span class="k">if</span> <span class="n">weight</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="c1"># On ajoute à la DataFrame originale les numéros de cluster pour chaque point.</span>
    <span class="n">df_point_cluster</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">mbk</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">Y</span><span class="p">),</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">COLUMN_CLUSTER_INDEX_NAME</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df_point_cluster</span><span class="p">)</span>

    <span class="c1"># La DataFrame &quot;df_infos_clusters&quot; associe à chaque numéro de cluster les </span>
    <span class="c1"># informations correspondantes.</span>
    <span class="c1"># En détails : une colonne &quot;centroids&quot; (centres de masse), </span>
    <span class="c1"># une colonne &quot;hulls&quot; (enveloppes convexes),</span>
    <span class="c1"># une colonne &quot;taille&quot; (nombre d&#39;établissements)</span>
    <span class="n">df_infos_clusters</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">mbk</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                                                        <span class="n">mbk</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span>
                                     <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">COLUMN_CENTROIDS_NAME</span><span class="p">]</span>
                                     <span class="p">)</span>
    <span class="n">df_infos_clusters</span> <span class="o">=</span> <span class="n">df_infos_clusters</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">clusterizer_utils</span><span class="o">.</span><span class="n">get_infos_clusters_taille</span><span class="p">(</span><span class="n">df</span><span class="p">))</span>
    <span class="n">df_infos_clusters</span> <span class="o">=</span> <span class="n">df_infos_clusters</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">clusterizer_utils</span><span class="o">.</span><span class="n">get_infos_clusters_enveloppes_convexes</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">column_geometry</span><span class="p">,</span> <span class="n">is_dict</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">df_infos_clusters</span> <span class="o">=</span> <span class="n">df_infos_clusters</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">clusterizer_utils</span><span class="o">.</span><span class="n">get_infos_clusters_poids</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s2">&quot;apet700&quot;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">df_infos_clusters</span></div>


<div class="viewcode-block" id="save_to_map"><a class="viewcode-back" href="../../../generated/src.clusterizer.clusterizer.save_to_map.html#src.clusterizer.clusterizer.save_to_map">[docs]</a><span class="k">def</span> <span class="nf">save_to_map</span><span class="p">(</span><span class="n">df_clusters</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">map</span><span class="p">:</span> <span class="n">folium</span><span class="o">.</span><span class="n">folium</span><span class="o">.</span><span class="n">Map</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nb_avant</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">folium</span><span class="o">.</span><span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sauvegarde les informations des clusters dans une carte Leaflet.</span>
<span class="sd">    Retourne la carte</span>

<span class="sd">    :param df_clusters: La DataFrame contenant les informations de chaque cluster</span>
<span class="sd">     (cf. deuxième sortie de la fonction clusterize)</span>
<span class="sd">    :param map: la carte à utiliser</span>
<span class="sd">     si un paramètre est spécifié : réecrit par dessus.</span>
<span class="sd">     si rien n&#39;est spécifié, génère une nouvelle carte</span>
<span class="sd">    :param nb_avant: nombre de clusters déjà réalisés dans le cas où plusieurs zones sont clusterisées à la suite</span>
<span class="sd">    :return: une carte complétée.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">map</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span>
            <span class="n">location</span><span class="o">=</span><span class="p">[</span><span class="mf">48.844952</span><span class="p">,</span> <span class="mf">2.339193</span><span class="p">],</span>
            <span class="n">zoom_start</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">tiles</span><span class="o">=</span><span class="s2">&quot;Stamen Terrain&quot;</span>
        <span class="p">)</span>

    <span class="n">couleurs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;darkslateblue&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="s1">&#39;darkred&#39;</span><span class="p">,</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span>
                <span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="s1">&#39;chocolate&#39;</span><span class="p">,</span> <span class="s1">&#39;darkgreen&#39;</span><span class="p">,</span> <span class="s1">&#39;seagreen&#39;</span><span class="p">,</span>
                <span class="s1">&#39;darkblue&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">]</span>

    <span class="n">centroids</span> <span class="o">=</span> <span class="n">df_clusters</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">COLUMN_CENTROIDS_NAME</span><span class="p">]</span>
    <span class="n">hulls</span> <span class="o">=</span> <span class="n">df_clusters</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">COLUMN_HULLS_NAME</span><span class="p">]</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="n">df_clusters</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">COLUMN_CLUSTER_SIZE_NAME</span><span class="p">]</span>
    <span class="n">poids</span> <span class="o">=</span> <span class="n">df_clusters</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">COLUMN_CLUSTER_MASS_NAME</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">centroids</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Centre de masse du cluster </span><span class="si">{</span><span class="n">k</span> <span class="o">+</span> <span class="n">nb_avant</span><span class="si">}</span><span class="s2"> : </span><span class="si">{</span><span class="n">sizes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="si">}</span><span class="s2"> etablissements. Poids : </span><span class="si">{</span><span class="n">poids</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">folium</span><span class="o">.</span><span class="n">CircleMarker</span><span class="p">(</span>
                <span class="n">location</span><span class="o">=</span><span class="p">[</span><span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">],</span>
                <span class="n">popup</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                <span class="n">radius</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="n">color</span> <span class="o">=</span><span class="s1">&#39;purple&#39;</span>
                <span class="c1"># icon=folium.Icon(color=couleurs[k % len(couleurs)], icon=&#39;info-sign&#39;)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hulls</span><span class="p">):</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Cluster </span><span class="si">{</span><span class="n">k</span> <span class="o">+</span> <span class="n">nb_avant</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span> <span class="o">==</span> <span class="n">Polygon</span><span class="p">:</span>
            <span class="c1"># Notre cluster a plus de trois points (autrement, le type serait Point ou LineString)</span>
            <span class="c1"># Donc c&#39;est utile d&#39;afficher l&#39;enveloppe convexe</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">clusterizer_utils</span><span class="o">.</span><span class="n">swap_xy</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span>
            <span class="n">folium</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">locations</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">popup</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">couleurs</span><span class="p">[</span><span class="n">k</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">couleurs</span><span class="p">)])</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span> <span class="o">==</span> <span class="n">MultiPolygon</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polygon</span><span class="p">:</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">clusterizer_utils</span><span class="o">.</span><span class="n">swap_xy</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span>
                <span class="n">folium</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">locations</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">popup</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">couleurs</span><span class="p">[</span><span class="n">k</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">couleurs</span><span class="p">)])</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>

    <span class="nb">map</span><span class="o">.</span><span class="n">get_root</span><span class="p">()</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span>
        <span class="n">folium</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span>
            <span class="s2">&quot;&lt;title&gt;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hulls</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; clusters&lt;/title&gt;&quot;</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="nb">map</span></div>

<div class="viewcode-block" id="test_geojson"><a class="viewcode-back" href="../../../generated/src.clusterizer.clusterizer.test_geojson.html#src.clusterizer.clusterizer.test_geojson">[docs]</a><span class="k">def</span> <span class="nf">test_geojson</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fonction interne (utilisée pour vérifier le bon fonctionnement de la clusterisation).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">nettoyer</span><span class="p">(</span><span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s2">&quot;../../essais/gis/input/reducted.geojson&quot;</span><span class="p">))</span>
    <span class="n">df</span><span class="p">,</span> <span class="n">df_clusters</span> <span class="o">=</span> <span class="n">clusterize</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">is_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">save_to_map</span><span class="p">(</span><span class="n">df_clusters</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;output/INSERT_NAME.html&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="calcule_nb_clusters_par_zone"><a class="viewcode-back" href="../../../generated/src.clusterizer.clusterizer.calcule_nb_clusters_par_zone.html#src.clusterizer.clusterizer.calcule_nb_clusters_par_zone">[docs]</a><span class="k">def</span> <span class="nf">calcule_nb_clusters_par_zone</span><span class="p">(</span><span class="n">liste_df</span><span class="p">,</span> <span class="n">nb_clusters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calcule le nombre de clusters à mettre dans chaque zone pour équilibrer les poids des clusters entre les zones</span>

<span class="sd">    :param liste_df: la liste des Dataframe correspondant aux différentes zones</span>
<span class="sd">    :param nb_clusters: le nombre de clusters total voulu</span>
<span class="sd">    :return: la liste des nombres de clusters par zones</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">poids_par_zone</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">liste_df</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">liste_df</span><span class="p">)):</span>
        <span class="n">poids_par_zone</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">clusterizer_utils</span><span class="o">.</span><span class="n">calculer_poids_cluster</span><span class="p">(</span><span class="n">liste_df</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;apet700&quot;</span><span class="p">)</span>
    <span class="n">poids_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">poids_par_zone</span><span class="p">)</span>
    <span class="n">nb_par_zone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">((</span><span class="n">poids_par_zone</span> <span class="o">/</span> <span class="n">poids_total</span> <span class="o">*</span> <span class="n">nb_clusters</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">nb_par_zone</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">nb_par_zone</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">liste_df</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>  <span class="c1"># il faut au moins un cluster par zone considérée</span>
    <span class="k">return</span> <span class="n">nb_par_zone</span></div>

<div class="viewcode-block" id="main_json"><a class="viewcode-back" href="../../../generated/src.clusterizer.clusterizer.main_json.html#src.clusterizer.clusterizer.main_json">[docs]</a><span class="k">def</span> <span class="nf">main_json</span><span class="p">(</span><span class="n">rayon</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">secteur_NAF</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">],</span> <span class="n">nb_clusters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">adresse_map</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;output/clusterized_map_seine.html&quot;</span><span class="p">,</span>
              <span class="n">seine_divide</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
              <span class="n">reduce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
              <span class="n">threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fonction principale à exécuter pour successivement ouvrir la DataFrame contenant les données,</span>
<span class="sd">    nettoyer la DataFrame, filtrer par secteurs NAF, ne garder que les magasins proche du centre de Paris,</span>
<span class="sd">    séparer par la Seine, clusteriser et sauvegarder dans une carte.</span>
<span class="sd">    La répartition entre les secteurs de la Seine est calculée automatiquement.</span>

<span class="sd">    :param rayon: le rayon (à partir du centre de Paris).</span>
<span class="sd">    :param secteur_NAF: les secteurs NAF à sélectionner.</span>
<span class="sd">    :param nb_clusters: le nombre de clusters à calculer.</span>
<span class="sd">    :param adresse_map: l&#39;adresse de la carte en sortie.</span>
<span class="sd">    :param seine_divide: mettre `True` pour séparer les clusters par la Seine</span>
<span class="sd">    :param reduce: mettre :code:`True` pour n&#39;utiliser qu&#39;une version allégée des données (plus rapide).</span>
<span class="sd">    :param threshold: nombre de données utilisées si reduce= :code:`True` </span>

<span class="sd">    :return: :code:`None` </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ouverture de la DataFrame...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;    &quot;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">nettoyer</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="s2">&quot;../../data/base_sirene_shortened.json&quot;</span><span class="p">),</span> <span class="n">reduce</span><span class="o">=</span><span class="n">reduce</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">secteur_NAF</span> <span class="o">!=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="p">:</span>
        <span class="n">list_section</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">secteur</span> <span class="ow">in</span> <span class="n">secteur_NAF</span> <span class="p">:</span>
            <span class="n">list_section</span> <span class="o">=</span> <span class="n">list_section</span> <span class="o">+</span> <span class="n">NAF_utils</span><span class="o">.</span><span class="n">get_NAFs_by_section</span><span class="p">(</span><span class="n">secteur</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">NAF_utils</span><span class="o">.</span><span class="n">filter_by_naf</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">list_section</span><span class="p">,</span> <span class="s2">&quot;apet700&quot;</span><span class="p">)</span>

    <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="si">:</span><span class="s2">2.3f</span><span class="si">}</span><span class="s2"> s&quot;</span><span class="p">)</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;On ne garde que les données du centre...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;    &quot;</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">clusterizer_utils</span><span class="o">.</span><span class="n">filter_nearby_paris</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">rayon</span><span class="p">,</span> <span class="n">is_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="si">:</span><span class="s2">2.3f</span><span class="si">}</span><span class="s2"> s&quot;</span><span class="p">)</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">seine_divide</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;On sépare par la Seine...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;    &quot;</span><span class="p">)</span>
        <span class="n">masque</span> <span class="o">=</span> <span class="n">rapport_a_la_seine_multiprocessing</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">]))</span>

        <span class="n">liste_df</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">no_zone</span> <span class="ow">in</span> <span class="n">DICT_GDF_ZONES</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">liste_df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">no_zone</span> <span class="o">==</span> <span class="n">masque</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="si">:</span><span class="s2">2.3f</span><span class="si">}</span><span class="s2"> s&quot;</span><span class="p">)</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Clusterisation...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;    &quot;</span><span class="p">)</span>

        <span class="n">liste_df_clusters</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">nb_clusters_par_zone</span> <span class="o">=</span> <span class="n">calcule_nb_clusters_par_zone</span><span class="p">(</span><span class="n">liste_df</span><span class="p">,</span> <span class="n">nb_clusters</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">no_zone</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NB_ZONES</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">liste_df_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">clusterize</span><span class="p">(</span><span class="n">liste_df</span><span class="p">[</span><span class="n">no_zone</span><span class="p">],</span> <span class="n">nb_clusters_par_zone</span><span class="p">[</span><span class="n">no_zone</span><span class="p">],</span> <span class="n">is_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">liste_df_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">nb_clusters_par_zone</span><span class="p">[</span><span class="n">no_zone</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># il n&#39;y a pas d&#39;établissements dans cette zone</span>

        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="si">:</span><span class="s2">2.3f</span><span class="si">}</span><span class="s2"> s&quot;</span><span class="p">)</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">else</span> <span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Clusterisation...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;    &quot;</span><span class="p">)</span>

        <span class="n">liste_df_clusters</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">liste_df_clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">clusterize</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">nb_clusters</span><span class="p">,</span> <span class="n">is_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="si">:</span><span class="s2">2.3f</span><span class="si">}</span><span class="s2"> s&quot;</span><span class="p">)</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Génération de la carte et sauvegarde...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;    &quot;</span><span class="p">)</span>

    <span class="n">nb_deja_faits</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nb">map</span> <span class="o">=</span> <span class="n">save_to_map</span><span class="p">(</span><span class="n">liste_df_clusters</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">no_zone</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">liste_df_clusters</span><span class="p">)):</span>
        <span class="n">nb_deja_faits</span> <span class="o">+=</span> <span class="n">nb_clusters_par_zone</span><span class="p">[</span><span class="n">no_zone</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">liste_df_clusters</span><span class="p">[</span><span class="n">no_zone</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">map</span> <span class="o">=</span> <span class="n">save_to_map</span><span class="p">(</span><span class="n">liste_df_clusters</span><span class="p">[</span><span class="n">no_zone</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="nb">map</span><span class="o">=</span><span class="nb">map</span><span class="p">,</span> <span class="n">nb_avant</span><span class="o">=</span><span class="n">nb_deja_faits</span><span class="p">)</span>

    <span class="nb">map</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">adresse_map</span><span class="p">)</span>

    <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="si">:</span><span class="s2">2.3f</span><span class="si">}</span><span class="s2"> s&quot;</span><span class="p">)</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Terminé !&quot;</span><span class="p">)</span></div>




<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># On exécute le programme avec la base SIRENE :</span>

    <span class="k">if</span> <span class="n">DEBUG_PLOT</span><span class="p">:</span>
        <span class="n">main_json</span><span class="p">(</span><span class="n">reduce</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># main_json(reduce = True, adresse_map=&quot;output/clusterized_map_optim_de_cython.html&quot;)</span>
        <span class="c1"># main_json(adresse_map=&quot;output/clusterized_map_optim_de_cython.html&quot;)</span>
        <span class="c1"># cProfile.run(&#39;main_json(adresse_map=&quot;output/clusterized_map_with_shapefile.html&quot;, reduce=True, threshold=10000)&#39;)</span>
        <span class="c1"># cProfile.run(&#39;main_json(rayon=1000, adresse_map=&quot;output/clusterized_map_with_shapefile.html&quot;)&#39;)</span>
        <span class="c1"># main_json(rayon=100, adresse_map=&quot;output/clusterized_map_with_shapefile_no_convex.html&quot;, reduce=True, threshold=10_000)</span>
        <span class="c1"># with PyCallGraph(output=GraphvizOutput()):</span>
        <span class="c1">#     main_json(rayon=100, adresse_map=&quot;output/clusterized_map_with_shapefile_no_convex.html&quot;, reduce=True, threshold=10_000)</span>
        <span class="n">main_json</span><span class="p">(</span><span class="n">rayon</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">nb_clusters</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">adresse_map</span><span class="o">=</span><span class="s2">&quot;output/clusterized_map_mutiprocessing_shp_full.html&quot;</span><span class="p">)</span><span class="c1">#, reduce=True, threshold=100_000)</span>
        <span class="c1"># with PyCallGraph(output=GraphvizOutput()):</span>
        <span class="c1">#     main_json(rayon=100, adresse_map=&quot;output/clusterized_map_with_shapefile_no_convex.html&quot;, reduce=True, threshold=10_000)</span>
        <span class="c1"># cProfile.run(&#39;main_json(rayon=100, adresse_map=&quot;output/clusterized_map_with_shapefile_no_convex.html&quot;, reduce=True, threshold=100_000)&#39;)</span>

<span class="c1">#### au maximum : </span>
<span class="c1"># avant multiprocessing</span>
<span class="c1"># $ python clusterizer.py </span>
<span class="c1"># Ouverture de la DataFrame...    6.922 s</span>
<span class="c1"># On ne garde que les données du centre...    1.110 s</span>
<span class="c1"># On sépare par la Seine...    424.805 s</span>
<span class="c1"># Clusterisation...    7.739 s</span>
<span class="c1"># Génération de la carte et sauvegarde...    0.108 s</span>
<span class="c1"># Terminé !</span>
<span class="c1"># -&gt; 440 secondes = 7 minutes 20</span>

<span class="c1"># après multiprocessing</span>
<span class="c1"># $ python clusterizer.py </span>
<span class="c1"># Ouverture de la DataFrame...    5.678 s</span>
<span class="c1"># On ne garde que les données du centre...    0.806 s</span>
<span class="c1"># On sépare par la Seine...    322.618 s</span>
<span class="c1"># Clusterisation...    14.862 s</span>
<span class="c1"># Génération de la carte et sauvegarde...    0.152 s</span>
<span class="c1"># Terminé !</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021 Judith Bellon, Gabrielle Vernet, César Almecija, Louis-Justin Tallot.

    </p>
  </div>
    
    
    
    Compilé avec <a href="https://www.sphinx-doc.org/">Sphinx</a> en utilisant un
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">thème</a>
    
    fourni par <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>